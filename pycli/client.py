
# python wrapper for package github.com/mason-leap-lab/infinicache/client within overall package client
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -output pycli -vm=python3 github.com/mason-leap-lab/infinicache/client

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _client
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from client import client
# and then refer to everything using client. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice [][]byte
class Slice_Slice_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_Slice_byte_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_byte.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_Slice_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_Slice_byte([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_Slice_byte_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_Slice_byte_len(self.handle)
				return Slice_Slice_byte(handle=_client.Slice_Slice_byte_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_byte(handle=_client.Slice_Slice_byte_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_Slice_byte_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_byte.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _client.Slice_Slice_byte_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_Slice_byte_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []consistent.Member
class Slice_consistent_Member(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_consistent_Member_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_consistent_Member.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_consistent_Member len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_consistent_Member([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_consistent_Member_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_consistent_Member_len(self.handle)
				return Slice_consistent_Member(handle=_client.Slice_consistent_Member_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.consistent_Member(handle=_client.Slice_consistent_Member_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_consistent_Member_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_consistent_Member.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _client.Slice_consistent_Member_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_consistent_Member_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string]float64
class Map_string_float64(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Map_string_float64_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_float64.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_client.Map_string_float64_set(self.handle, k, v)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Map_string_float64 len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'client.Map_string_float64({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _client.Map_string_float64_len(self.handle)
	def __getitem__(self, key):
		return _client.Map_string_float64_elem(self.handle, key)
	def __setitem__(self, key, value):
		_client.Map_string_float64_set(self.handle, key, value)
	def __delitem__(self, key):
		return _client.Map_string_float64_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_client.Map_string_float64_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _client.Map_string_float64_contains(self.handle, key)

# Python type for map map[string]interface{}
class Map_string_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Map_string_interface__CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_interface_.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_client.Map_string_interface__set(self.handle, k, v)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Map_string_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'client.Map_string_interface_({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _client.Map_string_interface__len(self.handle)
	def __getitem__(self, key):
		return _client.Map_string_interface__elem(self.handle, key)
	def __setitem__(self, key, value):
		_client.Map_string_interface__set(self.handle, key, value)
	def __delitem__(self, key):
		return _client.Map_string_interface__delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_client.Map_string_interface__keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _client.Map_string_interface__contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---
LargeObjectSplitUnit = 10000000
LargeObjectThreshold = 30000000


# ---- Global Variables: can only use functions to access ---
def ECConfig():
	"""
	ECConfig Gets Go Variable: client.ECConfig
	
	"""
	return go.consistent_Config(handle=_client.client_ECConfig())

def Set_ECConfig(value):
	"""
	Set_ECConfig Sets Go Variable: client.ECConfig
	
	"""
	if isinstance(value, go.GoClass):
		_client.client_Set_ECConfig(value.handle)
	else:
		_client.client_Set_ECConfig(value)

def HeaderTimeout():
	"""
	HeaderTimeout Gets Go Variable: client.HeaderTimeout
	
	"""
	return _client.client_HeaderTimeout()

def Set_HeaderTimeout(value):
	"""
	Set_HeaderTimeout Sets Go Variable: client.HeaderTimeout
	
	"""
	if isinstance(value, go.GoClass):
		_client.client_Set_HeaderTimeout(value.handle)
	else:
		_client.client_Set_HeaderTimeout(value)

def MaxLambdaStores():
	"""
	MaxLambdaStores Gets Go Variable: client.MaxLambdaStores
	
	"""
	return _client.client_MaxLambdaStores()

def Set_MaxLambdaStores(value):
	"""
	Set_MaxLambdaStores Sets Go Variable: client.MaxLambdaStores
	
	"""
	if isinstance(value, go.GoClass):
		_client.client_Set_MaxLambdaStores(value.handle)
	else:
		_client.client_Set_MaxLambdaStores(value)

def OccupantReadAllCloser():
	"""
	OccupantReadAllCloser Gets Go Variable: client.OccupantReadAllCloser
	
	"""
	return JoinReader(handle=_client.client_OccupantReadAllCloser())

def Set_OccupantReadAllCloser(value):
	"""
	Set_OccupantReadAllCloser Sets Go Variable: client.OccupantReadAllCloser
	
	"""
	if isinstance(value, go.GoClass):
		_client.client_Set_OccupantReadAllCloser(value.handle)
	else:
		_client.client_Set_OccupantReadAllCloser(value)

def PreflightTimeout():
	"""
	PreflightTimeout Gets Go Variable: client.PreflightTimeout
	
	"""
	return _client.client_PreflightTimeout()

def Set_PreflightTimeout(value):
	"""
	Set_PreflightTimeout Sets Go Variable: client.PreflightTimeout
	
	"""
	if isinstance(value, go.GoClass):
		_client.client_Set_PreflightTimeout(value.handle)
	else:
		_client.client_Set_PreflightTimeout(value)

def RequestAttempts():
	"""
	RequestAttempts Gets Go Variable: client.RequestAttempts
	
	"""
	return _client.client_RequestAttempts()

def Set_RequestAttempts(value):
	"""
	Set_RequestAttempts Sets Go Variable: client.RequestAttempts
	
	"""
	if isinstance(value, go.GoClass):
		_client.client_Set_RequestAttempts(value.handle)
	else:
		_client.client_Set_RequestAttempts(value)

def Timeout():
	"""
	Timeout Gets Go Variable: client.Timeout
	
	"""
	return _client.client_Timeout()

def Set_Timeout(value):
	"""
	Set_Timeout Sets Go Variable: client.Timeout
	
	"""
	if isinstance(value, go.GoClass):
		_client.client_Set_Timeout(value.handle)
	else:
		_client.client_Set_Timeout(value)



# ---- Interfaces ---

# Python type for interface client.ReadAllCloser
class ReadAllCloser(go.GoClass):
	"""ReadAllCloser Allows to get length and read all from the reader.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def Close(self):
		"""Close() str"""
		return _client.client_ReadAllCloser_Close(self.handle)
	def Len(self):
		"""Len() int"""
		return _client.client_ReadAllCloser_Len(self.handle)
	def Read(self, p):
		"""Read([]int p) int n, str err"""
		return _client.client_ReadAllCloser_Read(self.handle, p.handle)
	def ReadAll(self):
		"""ReadAll() []int, str"""
		return go.Slice_byte(handle=_client.client_ReadAllCloser_ReadAll(self.handle))

# Python type for interface client.WaitGroup
class WaitGroup(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def Add(self, arg_0, goRun=False):
		"""Add(int) """
		_client.client_WaitGroup_Add(self.handle, arg_0, goRun)
	def Done(self, goRun=False):
		"""Done() """
		_client.client_WaitGroup_Done(self.handle, goRun)
	def Wait(self, goRun=False):
		"""Wait() """
		_client.client_WaitGroup_Wait(self.handle, goRun)


# ---- Structs ---

# Python type for struct client.ClientConnMeta
class ClientConnMeta(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_ClientConnMeta_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.Addr = args[0]
			if "Addr" in kwargs:
				self.Addr = kwargs["Addr"]
			if  1 < len(args):
				self.AddrIdx = args[1]
			if "AddrIdx" in kwargs:
				self.AddrIdx = kwargs["AddrIdx"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.ClientConnMeta{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.ClientConnMeta ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Addr(self):
		return _client.client_ClientConnMeta_Addr_Get(self.handle)
	@Addr.setter
	def Addr(self, value):
		if isinstance(value, go.GoClass):
			_client.client_ClientConnMeta_Addr_Set(self.handle, value.handle)
		else:
			_client.client_ClientConnMeta_Addr_Set(self.handle, value)
	@property
	def AddrIdx(self):
		return _client.client_ClientConnMeta_AddrIdx_Get(self.handle)
	@AddrIdx.setter
	def AddrIdx(self, value):
		if isinstance(value, go.GoClass):
			_client.client_ClientConnMeta_AddrIdx_Set(self.handle, value.handle)
		else:
			_client.client_ClientConnMeta_AddrIdx_Set(self.handle, value)

# Python type for struct client.ClientRequest
class ClientRequest(go.aclient_Request):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_ClientRequest_CTor()
			_client.IncRef(self.handle)
			if  1 < len(args):
				self.Cmd = args[1]
			if "Cmd" in kwargs:
				self.Cmd = kwargs["Cmd"]
			if  2 < len(args):
				self.ReqId = args[2]
			if "ReqId" in kwargs:
				self.ReqId = kwargs["ReqId"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.ClientRequest{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.ClientRequest ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Cmd(self):
		return _client.client_ClientRequest_Cmd_Get(self.handle)
	@Cmd.setter
	def Cmd(self, value):
		if isinstance(value, go.GoClass):
			_client.client_ClientRequest_Cmd_Set(self.handle, value.handle)
		else:
			_client.client_ClientRequest_Cmd_Set(self.handle, value)
	@property
	def ReqId(self):
		return _client.client_ClientRequest_ReqId_Get(self.handle)
	@ReqId.setter
	def ReqId(self, value):
		if isinstance(value, go.GoClass):
			_client.client_ClientRequest_ReqId_Set(self.handle, value.handle)
		else:
			_client.client_ClientRequest_ReqId_Set(self.handle, value)

# Python type for struct client.DummyEncoder
class DummyEncoder(go.GoClass):
	"""DummyEncoder Dummpy encoder to support 0 parity.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_DummyEncoder_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.DataShards = args[0]
			if "DataShards" in kwargs:
				self.DataShards = kwargs["DataShards"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.DummyEncoder{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.DummyEncoder ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def DataShards(self):
		return _client.client_DummyEncoder_DataShards_Get(self.handle)
	@DataShards.setter
	def DataShards(self, value):
		if isinstance(value, go.GoClass):
			_client.client_DummyEncoder_DataShards_Set(self.handle, value.handle)
		else:
			_client.client_DummyEncoder_DataShards_Set(self.handle, value)
	def Encode(self, shards):
		"""Encode([][]int shards) str
		
		Encode reedsolomon.Encoder implmentation
		"""
		return _client.client_DummyEncoder_Encode(self.handle, shards.handle)
	def Verify(self, shards):
		"""Verify([][]int shards) bool, str
		
		Verify reedsolomon.Encoder implmentation
		"""
		return _client.client_DummyEncoder_Verify(self.handle, shards.handle)
	def Reconstruct(self, shards):
		"""Reconstruct([][]int shards) str err
		
		Reconstruct reedsolomon.Encoder implmentation
		"""
		return _client.client_DummyEncoder_Reconstruct(self.handle, shards.handle)
	def ReconstructData(self, shards):
		"""ReconstructData([][]int shards) str err
		
		ReconstructData reedsolomon.Encoder implmentation
		"""
		return _client.client_DummyEncoder_ReconstructData(self.handle, shards.handle)
	def Update(self, shards, newDatashards):
		"""Update([][]int shards, [][]int newDatashards) str
		
		Update reedsolomon.Encoder implmentation
		"""
		return _client.client_DummyEncoder_Update(self.handle, shards.handle, newDatashards.handle)
	def Split(self, data):
		"""Split([]int data) [][]int, str
		
		Split reedsolomon.Encoder implmentation
		"""
		return Slice_Slice_byte(handle=_client.client_DummyEncoder_Split(self.handle, data.handle))
	def Join(self, dst, shards, outSize):
		"""Join(object dst, [][]int shards, int outSize) str
		
		Join reedsolomon.Encoder implmentation
		"""
		return _client.client_DummyEncoder_Join(self.handle, dst.handle, shards.handle, outSize)

# Python type for struct client.JoinReader
class JoinReader(go.GoClass):
	"""JoinReader A ReadAllCloser implementation that can concat an array of []bytes\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_JoinReader_CTor()
			_client.IncRef(self.handle)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.JoinReader{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.JoinReader ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Read(self, p):
		"""Read([]int p) int n, str err
		
		Read io.Reader implementation
		"""
		return _client.client_JoinReader_Read(self.handle, p.handle)
	def Len(self):
		"""Len() int
		
		Len ReaderAllCloser implementation
		"""
		return _client.client_JoinReader_Len(self.handle)
	def ReadAll(self):
		"""ReadAll() []int buf, str err
		
		ReadAll ReaderAllCloser implementation
		"""
		return go.Slice_byte(handle=_client.client_JoinReader_ReadAll(self.handle))
	def Close(self):
		"""Close() str
		
		Close ReaderAllCloser implementation
		Drain reader if any read.
		"""
		return _client.client_JoinReader_Close(self.handle)

# Python type for struct client.PooledClient
class PooledClient(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_PooledClient_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.Concurrency = args[0]
			if "Concurrency" in kwargs:
				self.Concurrency = kwargs["Concurrency"]
			if  1 < len(args):
				self.NumDataShards = args[1]
			if "NumDataShards" in kwargs:
				self.NumDataShards = kwargs["NumDataShards"]
			if  2 < len(args):
				self.NumParityShards = args[2]
			if "NumParityShards" in kwargs:
				self.NumParityShards = kwargs["NumParityShards"]
			if  3 < len(args):
				self.ECMaxGoroutine = args[3]
			if "ECMaxGoroutine" in kwargs:
				self.ECMaxGoroutine = kwargs["ECMaxGoroutine"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.PooledClient{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.PooledClient ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Concurrency(self):
		"""Concurrency supported
		"""
		return _client.client_PooledClient_Concurrency_Get(self.handle)
	@Concurrency.setter
	def Concurrency(self, value):
		if isinstance(value, go.GoClass):
			_client.client_PooledClient_Concurrency_Set(self.handle, value.handle)
		else:
			_client.client_PooledClient_Concurrency_Set(self.handle, value)
	@property
	def NumDataShards(self):
		"""Default # of data shards
		"""
		return _client.client_PooledClient_NumDataShards_Get(self.handle)
	@NumDataShards.setter
	def NumDataShards(self, value):
		if isinstance(value, go.GoClass):
			_client.client_PooledClient_NumDataShards_Set(self.handle, value.handle)
		else:
			_client.client_PooledClient_NumDataShards_Set(self.handle, value)
	@property
	def NumParityShards(self):
		"""Default # of parity shards
		"""
		return _client.client_PooledClient_NumParityShards_Get(self.handle)
	@NumParityShards.setter
	def NumParityShards(self, value):
		if isinstance(value, go.GoClass):
			_client.client_PooledClient_NumParityShards_Set(self.handle, value.handle)
		else:
			_client.client_PooledClient_NumParityShards_Set(self.handle, value)
	@property
	def ECMaxGoroutine(self):
		"""Max goroutine used by Erasure Coding
		"""
		return _client.client_PooledClient_ECMaxGoroutine_Get(self.handle)
	@ECMaxGoroutine.setter
	def ECMaxGoroutine(self, value):
		if isinstance(value, go.GoClass):
			_client.client_PooledClient_ECMaxGoroutine_Set(self.handle, value.handle)
		else:
			_client.client_PooledClient_ECMaxGoroutine_Set(self.handle, value)
	def Get(self, key):
		"""Get(str key) object, str"""
		return ReadAllCloser(handle=_client.client_PooledClient_Get(self.handle, key))
	def Set(self, key, val):
		"""Set(str key, []int val) str"""
		return _client.client_PooledClient_Set(self.handle, key, val.handle)
	def Close(self, goRun=False):
		"""Close() """
		_client.client_PooledClient_Close(self.handle, goRun)

# Python type for struct client.Client
class Client(go.GoClass):
	"""Client InfiniCache client\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_Client_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.EC = args[0]
			if "EC" in kwargs:
				self.EC = kwargs["EC"]
			if  1 < len(args):
				self.Ring = args[1]
			if "Ring" in kwargs:
				self.Ring = kwargs["Ring"]
			if  2 < len(args):
				self.DataShards = args[2]
			if "DataShards" in kwargs:
				self.DataShards = kwargs["DataShards"]
			if  3 < len(args):
				self.ParityShards = args[3]
			if "ParityShards" in kwargs:
				self.ParityShards = kwargs["ParityShards"]
			if  4 < len(args):
				self.Shards = args[4]
			if "Shards" in kwargs:
				self.Shards = kwargs["Shards"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.Client{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.Client ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def EC(self):
		return go.reedsolomon_Encoder(handle=_client.client_Client_EC_Get(self.handle))
	@EC.setter
	def EC(self, value):
		if isinstance(value, go.GoClass):
			_client.client_Client_EC_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Ring(self):
		return go.Ptr_consistent_Consistent(handle=_client.client_Client_Ring_Get(self.handle))
	@Ring.setter
	def Ring(self, value):
		if isinstance(value, go.GoClass):
			_client.client_Client_Ring_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def DataShards(self):
		return _client.client_Client_DataShards_Get(self.handle)
	@DataShards.setter
	def DataShards(self, value):
		if isinstance(value, go.GoClass):
			_client.client_Client_DataShards_Set(self.handle, value.handle)
		else:
			_client.client_Client_DataShards_Set(self.handle, value)
	@property
	def ParityShards(self):
		return _client.client_Client_ParityShards_Get(self.handle)
	@ParityShards.setter
	def ParityShards(self, value):
		if isinstance(value, go.GoClass):
			_client.client_Client_ParityShards_Set(self.handle, value.handle)
		else:
			_client.client_Client_ParityShards_Set(self.handle, value)
	@property
	def Shards(self):
		return _client.client_Client_Shards_Get(self.handle)
	@Shards.setter
	def Shards(self, value):
		if isinstance(value, go.GoClass):
			_client.client_Client_Shards_Set(self.handle, value.handle)
		else:
			_client.client_Client_Shards_Set(self.handle, value)
	def Dial(self, addrArr):
		"""Dial([]str addrArr) bool
		
		Dial Dial proxies
		"""
		return _client.client_Client_Dial(self.handle, addrArr.handle)
	def Close(self, goRun=False):
		"""Close() 
		
		Close Close the client
		"""
		_client.client_Client_Close(self.handle, goRun)
	def Set(self, key, val):
		"""Set(str key, []int val) bool
		
		Set New set API
		Internal error if result is false.
		"""
		return _client.client_Client_Set(self.handle, key, val.handle)
	def Get(self, key):
		"""Get(str key) object, str
		
		Get New get API. No size is required.
		Internal error if the bool is set to false
		"""
		return ReadAllCloser(handle=_client.client_Client_Get(self.handle, key))
	def GetVal(self, key):
		"""GetVal(str key) []int, str
		
		Get New get API. No size is required.
		Internal error if the bool is set to false
		"""
		return go.Slice_byte(handle=_client.client_Client_GetVal(self.handle, key))
	def ReadResponse(self, req):
		"""ReadResponse(object req) str"""
		return _client.client_Client_ReadResponse(self.handle, req.handle)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewJoinReader(data, size):
	"""NewJoinReader(str data, int size) object"""
	return JoinReader(handle=_client.client_NewJoinReader(data, size))
def NewClient(dataShards, parityShards, ecMaxGoroutine):
	"""NewClient(int dataShards, int parityShards, int ecMaxGoroutine) object
	
	NewClient Create a client instance.
	"""
	return Client(handle=_client.client_NewClient(dataShards, parityShards, ecMaxGoroutine))


# ---- Functions ---
def FlushLog(goRun=False):
	"""FlushLog() 
	
	FlushLog Flush logs to the file.y
	"""
	_client.client_FlushLog(goRun)
def NewEncoder(dataShards, parityShards, ecMaxGoroutine):
	"""NewEncoder(int dataShards, int parityShards, int ecMaxGoroutine) object
	
	NewEncoder Helper function to create a encoder
	"""
	return go.reedsolomon_Encoder(handle=_client.client_NewEncoder(dataShards, parityShards, ecMaxGoroutine))
def CreateLog(opts, goRun=False):
	"""CreateLog(object opts) 
	
	CreateLog Enabling evaluation log in client lib.
	"""
	_client.client_CreateLog(opts.handle, goRun)


