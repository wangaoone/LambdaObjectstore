/*
cgo stubs for package client.
File is generated by gopy. Do not edit.
gopy build -output pycli -vm=python3 github.com/mason-leap-lab/infinicache/client
*/

package main

/*

#cgo CFLAGS: -I/usr/local/opt/python@3.9/Frameworks/Python.framework/Versions/3.9/include/python3.9 -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: -L/usr/local/opt/python@3.9/Frameworks/Python.framework/Versions/3.9/lib -lpython3.9 -ldl   -framework CoreFoundation

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"fmt"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"io"
	"time"

	"github.com/buraksezer/consistent"
	"github.com/klauspost/reedsolomon"
	"github.com/mason-leap-lab/infinicache/client"
	aclient "github.com/mason-leap-lab/infinicache/common/redeo/client"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// --- generated code for package: client below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *consistent.Consistent
func ptrFromHandle_Ptr_consistent_Consistent(h CGoHandle) *consistent.Consistent {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*consistent.Consistent")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(consistent.Consistent{})).(*consistent.Consistent)
}
func handleFromPtr_Ptr_consistent_Consistent(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*consistent.Consistent", p))
}

// Converters for non-pointer handles for type: consistent.Config
func ptrFromHandle_consistent_Config(h CGoHandle) *consistent.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "consistent.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(consistent.Config{})).(*consistent.Config)
}
func handleFromPtr_consistent_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("consistent.Config", p))
}

// Converters for non-pointer handles for type: consistent.Consistent
func ptrFromHandle_consistent_Consistent(h CGoHandle) *consistent.Consistent {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "consistent.Consistent")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(consistent.Consistent{})).(*consistent.Consistent)
}
func handleFromPtr_consistent_Consistent(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("consistent.Consistent", p))
}

// Converters for pointer handles for type: consistent.Hasher
func ptrFromHandle_consistent_Hasher(h CGoHandle) consistent.Hasher {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "consistent.Hasher")
	if p == nil {
		return nil
	}
	return p.(consistent.Hasher)
}
func handleFromPtr_consistent_Hasher(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("consistent.Hasher", p))
}

// Converters for pointer handles for type: consistent.Member
func ptrFromHandle_consistent_Member(h CGoHandle) consistent.Member {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "consistent.Member")
	if p == nil {
		return nil
	}
	return p.(consistent.Member)
}
func handleFromPtr_consistent_Member(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("consistent.Member", p))
}

// Converters for pointer handles for type: reedsolomon.Encoder
func ptrFromHandle_reedsolomon_Encoder(h CGoHandle) reedsolomon.Encoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "reedsolomon.Encoder")
	if p == nil {
		return nil
	}
	return p.(reedsolomon.Encoder)
}
func handleFromPtr_reedsolomon_Encoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("reedsolomon.Encoder", p))
}

// Converters for pointer handles for type: aclient.Request
func ptrFromHandle_aclient_Request(h CGoHandle) aclient.Request {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "aclient.Request")
	if p == nil {
		return nil
	}
	return p.(aclient.Request)
}
func handleFromPtr_aclient_Request(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("aclient.Request", p))
}

// Converters for pointer handles for type: io.Writer
func ptrFromHandle_io_Writer(h CGoHandle) io.Writer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Writer")
	if p == nil {
		return nil
	}
	return p.(io.Writer)
}
func handleFromPtr_io_Writer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Writer", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: client ---

// ---- Types ---

// Converters for pointer handles for type: *client.Client
func ptrFromHandle_Ptr_client_Client(h CGoHandle) *client.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.Client{})).(*client.Client)
}
func handleFromPtr_Ptr_client_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.Client", p))
}

// Converters for pointer handles for type: *client.ClientConnMeta
func ptrFromHandle_Ptr_client_ClientConnMeta(h CGoHandle) *client.ClientConnMeta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.ClientConnMeta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.ClientConnMeta{})).(*client.ClientConnMeta)
}
func handleFromPtr_Ptr_client_ClientConnMeta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.ClientConnMeta", p))
}

// Converters for pointer handles for type: *client.ClientRequest
func ptrFromHandle_Ptr_client_ClientRequest(h CGoHandle) *client.ClientRequest {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.ClientRequest")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.ClientRequest{})).(*client.ClientRequest)
}
func handleFromPtr_Ptr_client_ClientRequest(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.ClientRequest", p))
}

// Converters for pointer handles for type: *client.DummyEncoder
func ptrFromHandle_Ptr_client_DummyEncoder(h CGoHandle) *client.DummyEncoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.DummyEncoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.DummyEncoder{})).(*client.DummyEncoder)
}
func handleFromPtr_Ptr_client_DummyEncoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.DummyEncoder", p))
}

// Converters for pointer handles for type: *client.JoinReader
func ptrFromHandle_Ptr_client_JoinReader(h CGoHandle) *client.JoinReader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.JoinReader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.JoinReader{})).(*client.JoinReader)
}
func handleFromPtr_Ptr_client_JoinReader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.JoinReader", p))
}

// Converters for pointer handles for type: *client.PooledClient
func ptrFromHandle_Ptr_client_PooledClient(h CGoHandle) *client.PooledClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.PooledClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.PooledClient{})).(*client.PooledClient)
}
func handleFromPtr_Ptr_client_PooledClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.PooledClient", p))
}

// Converters for implicit pointer handles for type: [][]byte
func ptrFromHandle_Slice_Slice_byte(h CGoHandle) *[][]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]byte")
	if p == nil {
		return nil
	}
	return p.(*[][]byte)
}
func deptrFromHandle_Slice_Slice_byte(h CGoHandle) [][]byte {
	p := ptrFromHandle_Slice_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]byte", p))
}

// --- wrapping slice: [][]byte ---
//export Slice_Slice_byte_CTor
func Slice_Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&[][]byte{}))
}

//export Slice_Slice_byte_len
func Slice_Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_byte(handle))
}

//export Slice_Slice_byte_elem
func Slice_Slice_byte_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	return handleFromPtr_Slice_byte(s[_idx])
}

//export Slice_Slice_byte_subslice
func Slice_Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&ss))
}

//export Slice_Slice_byte_set
func Slice_Slice_byte_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	s[_idx] = deptrFromHandle_Slice_byte(_vl)
}

//export Slice_Slice_byte_append
func Slice_Slice_byte_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_byte(handle)
	*s = append(*s, deptrFromHandle_Slice_byte(_vl))
}

// Converters for implicit pointer handles for type: []consistent.Member
func ptrFromHandle_Slice_consistent_Member(h CGoHandle) *[]consistent.Member {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]consistent.Member")
	if p == nil {
		return nil
	}
	return p.(*[]consistent.Member)
}
func deptrFromHandle_Slice_consistent_Member(h CGoHandle) []consistent.Member {
	p := ptrFromHandle_Slice_consistent_Member(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_consistent_Member(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]consistent.Member", p))
}

// --- wrapping slice: []consistent.Member ---
//export Slice_consistent_Member_CTor
func Slice_consistent_Member_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_consistent_Member(&[]consistent.Member{}))
}

//export Slice_consistent_Member_len
func Slice_consistent_Member_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_consistent_Member(handle))
}

//export Slice_consistent_Member_elem
func Slice_consistent_Member_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_consistent_Member(handle)
	return handleFromPtr_consistent_Member(s[_idx])
}

//export Slice_consistent_Member_subslice
func Slice_consistent_Member_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_consistent_Member(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_consistent_Member(&ss))
}

//export Slice_consistent_Member_set
func Slice_consistent_Member_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_consistent_Member(handle)
	s[_idx] = ptrFromHandle_consistent_Member(_vl)
}

//export Slice_consistent_Member_append
func Slice_consistent_Member_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_consistent_Member(handle)
	*s = append(*s, ptrFromHandle_consistent_Member(_vl))
}

// Converters for non-pointer handles for type: client.Client
func ptrFromHandle_client_Client(h CGoHandle) *client.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.Client{})).(*client.Client)
}
func handleFromPtr_client_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.Client", p))
}

// Converters for non-pointer handles for type: client.ClientConnMeta
func ptrFromHandle_client_ClientConnMeta(h CGoHandle) *client.ClientConnMeta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.ClientConnMeta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.ClientConnMeta{})).(*client.ClientConnMeta)
}
func handleFromPtr_client_ClientConnMeta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.ClientConnMeta", p))
}

// Converters for non-pointer handles for type: client.ClientRequest
func ptrFromHandle_client_ClientRequest(h CGoHandle) *client.ClientRequest {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.ClientRequest")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.ClientRequest{})).(*client.ClientRequest)
}
func handleFromPtr_client_ClientRequest(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.ClientRequest", p))
}

// Converters for non-pointer handles for type: client.DummyEncoder
func ptrFromHandle_client_DummyEncoder(h CGoHandle) *client.DummyEncoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.DummyEncoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.DummyEncoder{})).(*client.DummyEncoder)
}
func handleFromPtr_client_DummyEncoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.DummyEncoder", p))
}

// Converters for non-pointer handles for type: client.JoinReader
func ptrFromHandle_client_JoinReader(h CGoHandle) *client.JoinReader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.JoinReader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.JoinReader{})).(*client.JoinReader)
}
func handleFromPtr_client_JoinReader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.JoinReader", p))
}

// Converters for non-pointer handles for type: client.PooledClient
func ptrFromHandle_client_PooledClient(h CGoHandle) *client.PooledClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.PooledClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.PooledClient{})).(*client.PooledClient)
}
func handleFromPtr_client_PooledClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.PooledClient", p))
}

// Converters for pointer handles for type: client.ReadAllCloser
func ptrFromHandle_client_ReadAllCloser(h CGoHandle) client.ReadAllCloser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.ReadAllCloser")
	if p == nil {
		return nil
	}
	return p.(client.ReadAllCloser)
}
func handleFromPtr_client_ReadAllCloser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.ReadAllCloser", p))
}

// Converters for pointer handles for type: client.WaitGroup
func ptrFromHandle_client_WaitGroup(h CGoHandle) client.WaitGroup {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.WaitGroup")
	if p == nil {
		return nil
	}
	return p.(client.WaitGroup)
}
func handleFromPtr_client_WaitGroup(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.WaitGroup", p))
}

// Converters for implicit pointer handles for type: map[string]float64
func ptrFromHandle_Map_string_float64(h CGoHandle) *map[string]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]float64")
	if p == nil {
		return nil
	}
	return p.(*map[string]float64)
}
func deptrFromHandle_Map_string_float64(h CGoHandle) map[string]float64 {
	p := ptrFromHandle_Map_string_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]float64", p))
}

// --- wrapping map: map[string]float64 ---
//export Map_string_float64_CTor
func Map_string_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_float64(&map[string]float64{}))
}

//export Map_string_float64_len
func Map_string_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_float64(handle))
}

//export Map_string_float64_elem
func Map_string_float64_elem(handle CGoHandle, _ky *C.char) C.double {
	s := deptrFromHandle_Map_string_float64(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.double(v)
}

//export Map_string_float64_contains
func Map_string_float64_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_float64(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_float64_set
func Map_string_float64_set(handle CGoHandle, _ky *C.char, _vl C.double) {
	s := deptrFromHandle_Map_string_float64(handle)
	s[C.GoString(_ky)] = float64(_vl)
}

//export Map_string_float64_delete
func Map_string_float64_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_float64(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_float64_keys
func Map_string_float64_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_float64(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]interface{}
func ptrFromHandle_Map_string_interface_(h CGoHandle) *map[string]interface{} {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]interface{}")
	if p == nil {
		return nil
	}
	return p.(*map[string]interface{})
}
func deptrFromHandle_Map_string_interface_(h CGoHandle) map[string]interface{} {
	p := ptrFromHandle_Map_string_interface_(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_interface_(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]interface{}", p))
}

// --- wrapping map: map[string]interface{} ---
//export Map_string_interface__CTor
func Map_string_interface__CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_interface_(&map[string]interface{}{}))
}

//export Map_string_interface__len
func Map_string_interface__len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_interface_(handle))
}

//export Map_string_interface__elem
func Map_string_interface__elem(handle CGoHandle, _ky *C.char) *C.char {
	s := deptrFromHandle_Map_string_interface_(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(fmt.Sprintf("%s", (v)))
}

//export Map_string_interface__contains
func Map_string_interface__contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_interface_(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_interface__set
func Map_string_interface__set(handle CGoHandle, _ky *C.char, _vl *C.char) {
	s := deptrFromHandle_Map_string_interface_(handle)
	s[C.GoString(_ky)] = C.GoString(_vl)
}

//export Map_string_interface__delete
func Map_string_interface__delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_interface_(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_interface__keys
func Map_string_interface__keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_interface_(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---
//export client_ECConfig
func client_ECConfig() CGoHandle {
	return handleFromPtr_consistent_Config(&client.ECConfig)
}

//export client_Set_ECConfig
func client_Set_ECConfig(val CGoHandle) {
	client.ECConfig = *ptrFromHandle_consistent_Config(val)
}

//export client_HeaderTimeout
func client_HeaderTimeout() C.longlong {
	return C.longlong(int64(client.HeaderTimeout))
}

//export client_Set_HeaderTimeout
func client_Set_HeaderTimeout(val C.longlong) {
	client.HeaderTimeout = time.Duration(int64(val))
}

//export client_MaxLambdaStores
func client_MaxLambdaStores() C.longlong {
	return C.longlong(client.MaxLambdaStores)
}

//export client_Set_MaxLambdaStores
func client_Set_MaxLambdaStores(val C.longlong) {
	client.MaxLambdaStores = int(val)
}

//export client_OccupantReadAllCloser
func client_OccupantReadAllCloser() CGoHandle {
	return handleFromPtr_Ptr_client_JoinReader(client.OccupantReadAllCloser)
}

//export client_Set_OccupantReadAllCloser
func client_Set_OccupantReadAllCloser(val CGoHandle) {
	client.OccupantReadAllCloser = ptrFromHandle_Ptr_client_JoinReader(val)
}

//export client_PreflightTimeout
func client_PreflightTimeout() C.longlong {
	return C.longlong(int64(client.PreflightTimeout))
}

//export client_Set_PreflightTimeout
func client_Set_PreflightTimeout(val C.longlong) {
	client.PreflightTimeout = time.Duration(int64(val))
}

//export client_RequestAttempts
func client_RequestAttempts() C.longlong {
	return C.longlong(client.RequestAttempts)
}

//export client_Set_RequestAttempts
func client_Set_RequestAttempts(val C.longlong) {
	client.RequestAttempts = int(val)
}

//export client_Timeout
func client_Timeout() C.longlong {
	return C.longlong(int64(client.Timeout))
}

//export client_Set_Timeout
func client_Set_Timeout(val C.longlong) {
	client.Timeout = time.Duration(int64(val))
}

// ---- Interfaces ---

//export client_ReadAllCloser_Close
func client_ReadAllCloser_Close(_handle CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.ReadAllCloser")
	if __err != nil {
		return C.CString("")
	}
	__err = vifc.(client.ReadAllCloser).Close()

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_ReadAllCloser_Len
func client_ReadAllCloser_Len(_handle CGoHandle) C.longlong {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.ReadAllCloser")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(vifc.(client.ReadAllCloser).Len())

}

//export client_ReadAllCloser_Read
func client_ReadAllCloser_Read(_handle CGoHandle, p CGoHandle) C.longlong {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.ReadAllCloser")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := vifc.(client.ReadAllCloser).Read(deptrFromHandle_Slice_byte(p))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

//export client_ReadAllCloser_ReadAll
func client_ReadAllCloser_ReadAll(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.ReadAllCloser")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret, __err := vifc.(client.ReadAllCloser).ReadAll()

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export client_WaitGroup_Add
func client_WaitGroup_Add(_handle CGoHandle, arg_0 C.longlong, goRun C.char) {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WaitGroup")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.WaitGroup).Add(int(arg_0))
	} else {
		vifc.(client.WaitGroup).Add(int(arg_0))
	}
}

//export client_WaitGroup_Done
func client_WaitGroup_Done(_handle CGoHandle, goRun C.char) {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WaitGroup")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.WaitGroup).Done()
	} else {
		vifc.(client.WaitGroup).Done()
	}
}

//export client_WaitGroup_Wait
func client_WaitGroup_Wait(_handle CGoHandle, goRun C.char) {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WaitGroup")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.WaitGroup).Wait()
	} else {
		vifc.(client.WaitGroup).Wait()
	}
}

// ---- Structs ---

// --- wrapping struct: client.ClientConnMeta ---
//export client_ClientConnMeta_CTor
func client_ClientConnMeta_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_ClientConnMeta(&client.ClientConnMeta{}))
}

//export client_ClientConnMeta_Addr_Get
func client_ClientConnMeta_Addr_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_ClientConnMeta(handle)
	return C.CString(op.Addr)
}

//export client_ClientConnMeta_Addr_Set
func client_ClientConnMeta_Addr_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_ClientConnMeta(handle)
	op.Addr = C.GoString(val)
}

//export client_ClientConnMeta_AddrIdx_Get
func client_ClientConnMeta_AddrIdx_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_client_ClientConnMeta(handle)
	return C.longlong(op.AddrIdx)
}

//export client_ClientConnMeta_AddrIdx_Set
func client_ClientConnMeta_AddrIdx_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_client_ClientConnMeta(handle)
	op.AddrIdx = int(val)
}

// --- wrapping struct: client.ClientRequest ---
//export client_ClientRequest_CTor
func client_ClientRequest_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_ClientRequest(&client.ClientRequest{}))
}

//export client_ClientRequest_Cmd_Get
func client_ClientRequest_Cmd_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_ClientRequest(handle)
	return C.CString(op.Cmd)
}

//export client_ClientRequest_Cmd_Set
func client_ClientRequest_Cmd_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_ClientRequest(handle)
	op.Cmd = C.GoString(val)
}

//export client_ClientRequest_ReqId_Get
func client_ClientRequest_ReqId_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_ClientRequest(handle)
	return C.CString(op.ReqId)
}

//export client_ClientRequest_ReqId_Set
func client_ClientRequest_ReqId_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_ClientRequest(handle)
	op.ReqId = C.GoString(val)
}

// --- wrapping struct: client.DummyEncoder ---
//export client_DummyEncoder_CTor
func client_DummyEncoder_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_DummyEncoder(&client.DummyEncoder{}))
}

//export client_DummyEncoder_DataShards_Get
func client_DummyEncoder_DataShards_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_client_DummyEncoder(handle)
	return C.longlong(op.DataShards)
}

//export client_DummyEncoder_DataShards_Set
func client_DummyEncoder_DataShards_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_client_DummyEncoder(handle)
	op.DataShards = int(val)
}

//export client_DummyEncoder_Encode
func client_DummyEncoder_Encode(_handle CGoHandle, shards CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.DummyEncoder")
	if __err != nil {
		return C.CString("")
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(client.DummyEncoder{})).(*client.DummyEncoder).Encode(deptrFromHandle_Slice_Slice_byte(shards))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_DummyEncoder_Verify
func client_DummyEncoder_Verify(_handle CGoHandle, shards CGoHandle) C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.DummyEncoder")
	if __err != nil {
		return boolGoToPy(false)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(client.DummyEncoder{})).(*client.DummyEncoder).Verify(deptrFromHandle_Slice_Slice_byte(shards))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return boolGoToPy(false)
	}
	return boolGoToPy(cret)
}

//export client_DummyEncoder_Reconstruct
func client_DummyEncoder_Reconstruct(_handle CGoHandle, shards CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.DummyEncoder")
	if __err != nil {
		return C.CString("")
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(client.DummyEncoder{})).(*client.DummyEncoder).Reconstruct(deptrFromHandle_Slice_Slice_byte(shards))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_DummyEncoder_ReconstructData
func client_DummyEncoder_ReconstructData(_handle CGoHandle, shards CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.DummyEncoder")
	if __err != nil {
		return C.CString("")
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(client.DummyEncoder{})).(*client.DummyEncoder).ReconstructData(deptrFromHandle_Slice_Slice_byte(shards))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_DummyEncoder_Update
func client_DummyEncoder_Update(_handle CGoHandle, shards CGoHandle, newDatashards CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.DummyEncoder")
	if __err != nil {
		return C.CString("")
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(client.DummyEncoder{})).(*client.DummyEncoder).Update(deptrFromHandle_Slice_Slice_byte(shards), deptrFromHandle_Slice_Slice_byte(newDatashards))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_DummyEncoder_Split
func client_DummyEncoder_Split(_handle CGoHandle, data CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.DummyEncoder")
	if __err != nil {
		return handleFromPtr_Slice_Slice_byte(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(client.DummyEncoder{})).(*client.DummyEncoder).Split(deptrFromHandle_Slice_byte(data))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_Slice_byte(nil)
	}
	return handleFromPtr_Slice_Slice_byte(&cret)
}

//export client_DummyEncoder_Join
func client_DummyEncoder_Join(_handle CGoHandle, dst CGoHandle, shards CGoHandle, outSize C.longlong) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.DummyEncoder")
	if __err != nil {
		return C.CString("")
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(client.DummyEncoder{})).(*client.DummyEncoder).Join(ptrFromHandle_io_Writer(dst), deptrFromHandle_Slice_Slice_byte(shards), int(outSize))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: client.JoinReader ---
//export client_JoinReader_CTor
func client_JoinReader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_JoinReader(&client.JoinReader{}))
}

//export client_JoinReader_Read
func client_JoinReader_Read(_handle CGoHandle, p CGoHandle) C.longlong {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.JoinReader")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(client.JoinReader{})).(*client.JoinReader).Read(deptrFromHandle_Slice_byte(p))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

//export client_JoinReader_Len
func client_JoinReader_Len(_handle CGoHandle) C.longlong {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.JoinReader")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(client.JoinReader{})).(*client.JoinReader).Len())

}

//export client_JoinReader_ReadAll
func client_JoinReader_ReadAll(_handle CGoHandle) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.JoinReader")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(client.JoinReader{})).(*client.JoinReader).ReadAll()

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export client_JoinReader_Close
func client_JoinReader_Close(_handle CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.JoinReader")
	if __err != nil {
		return C.CString("")
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(client.JoinReader{})).(*client.JoinReader).Close()

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: client.PooledClient ---
//export client_PooledClient_CTor
func client_PooledClient_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_PooledClient(&client.PooledClient{}))
}

//export client_PooledClient_Concurrency_Get
func client_PooledClient_Concurrency_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_client_PooledClient(handle)
	return C.longlong(op.Concurrency)
}

//export client_PooledClient_Concurrency_Set
func client_PooledClient_Concurrency_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_client_PooledClient(handle)
	op.Concurrency = int(val)
}

//export client_PooledClient_NumDataShards_Get
func client_PooledClient_NumDataShards_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_client_PooledClient(handle)
	return C.longlong(op.NumDataShards)
}

//export client_PooledClient_NumDataShards_Set
func client_PooledClient_NumDataShards_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_client_PooledClient(handle)
	op.NumDataShards = int(val)
}

//export client_PooledClient_NumParityShards_Get
func client_PooledClient_NumParityShards_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_client_PooledClient(handle)
	return C.longlong(op.NumParityShards)
}

//export client_PooledClient_NumParityShards_Set
func client_PooledClient_NumParityShards_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_client_PooledClient(handle)
	op.NumParityShards = int(val)
}

//export client_PooledClient_ECMaxGoroutine_Get
func client_PooledClient_ECMaxGoroutine_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_client_PooledClient(handle)
	return C.longlong(op.ECMaxGoroutine)
}

//export client_PooledClient_ECMaxGoroutine_Set
func client_PooledClient_ECMaxGoroutine_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_client_PooledClient(handle)
	op.ECMaxGoroutine = int(val)
}

//export client_PooledClient_Get
func client_PooledClient_Get(_handle CGoHandle, key *C.char) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.PooledClient")
	if __err != nil {
		return handleFromPtr_client_ReadAllCloser(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(client.PooledClient{})).(*client.PooledClient).Get(C.GoString(key))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_client_ReadAllCloser(nil)
	}
	return handleFromPtr_client_ReadAllCloser(cret)
}

//export client_PooledClient_Set
func client_PooledClient_Set(_handle CGoHandle, key *C.char, val CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.PooledClient")
	if __err != nil {
		return C.CString("")
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(client.PooledClient{})).(*client.PooledClient).Set(C.GoString(key), deptrFromHandle_Slice_byte(val))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_PooledClient_Close
func client_PooledClient_Close(_handle CGoHandle, goRun C.char) {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.PooledClient")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.PooledClient{})).(*client.PooledClient).Close()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.PooledClient{})).(*client.PooledClient).Close()
	}
}

// --- wrapping struct: client.Client ---
//export client_Client_CTor
func client_Client_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_Client(&client.Client{}))
}

//export client_Client_EC_Get
func client_Client_EC_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_Client(handle)
	return handleFromPtr_reedsolomon_Encoder(op.EC)
}

//export client_Client_EC_Set
func client_Client_EC_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_Client(handle)
	op.EC = ptrFromHandle_reedsolomon_Encoder(val)
}

//export client_Client_Ring_Get
func client_Client_Ring_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_Client(handle)
	return handleFromPtr_Ptr_consistent_Consistent(op.Ring)
}

//export client_Client_Ring_Set
func client_Client_Ring_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_Client(handle)
	op.Ring = ptrFromHandle_Ptr_consistent_Consistent(val)
}

//export client_Client_DataShards_Get
func client_Client_DataShards_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_client_Client(handle)
	return C.longlong(op.DataShards)
}

//export client_Client_DataShards_Set
func client_Client_DataShards_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_client_Client(handle)
	op.DataShards = int(val)
}

//export client_Client_ParityShards_Get
func client_Client_ParityShards_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_client_Client(handle)
	return C.longlong(op.ParityShards)
}

//export client_Client_ParityShards_Set
func client_Client_ParityShards_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_client_Client(handle)
	op.ParityShards = int(val)
}

//export client_Client_Shards_Get
func client_Client_Shards_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_client_Client(handle)
	return C.longlong(op.Shards)
}

//export client_Client_Shards_Set
func client_Client_Shards_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_client_Client(handle)
	op.Shards = int(val)
}

//export client_Client_Dial
func client_Client_Dial(_handle CGoHandle, addrArr CGoHandle) C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.Client")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(client.Client{})).(*client.Client).Dial(deptrFromHandle_Slice_string(addrArr)))

}

//export client_Client_Close
func client_Client_Close(_handle CGoHandle, goRun C.char) {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.Client")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.Client{})).(*client.Client).Close()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.Client{})).(*client.Client).Close()
	}
}

//export client_Client_Set
func client_Client_Set(_handle CGoHandle, key *C.char, val CGoHandle) C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.Client")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(client.Client{})).(*client.Client).Set(C.GoString(key), deptrFromHandle_Slice_byte(val)))

}

//export client_Client_Get
func client_Client_Get(_handle CGoHandle, key *C.char) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.Client")
	if __err != nil {
		return handleFromPtr_client_ReadAllCloser(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(client.Client{})).(*client.Client).Get(C.GoString(key))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_client_ReadAllCloser(nil)
	}
	return handleFromPtr_client_ReadAllCloser(cret)
}

//export client_Client_GetVal
func client_Client_GetVal(_handle CGoHandle, key *C.char) CGoHandle {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.Client")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(client.Client{})).(*client.Client).GetVal(C.GoString(key))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export client_Client_ReadResponse
func client_Client_ReadResponse(_handle CGoHandle, req CGoHandle) *C.char {
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.Client")
	if __err != nil {
		return C.CString("")
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(client.Client{})).(*client.Client).ReadResponse(ptrFromHandle_aclient_Request(req))

	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export client_NewJoinReader
func client_NewJoinReader(data *C.char, size C.longlong) CGoHandle {
	return handleFromPtr_Ptr_client_JoinReader(client.NewJoinReader(C.GoString(data), int(size)))

}

//export client_NewClient
func client_NewClient(dataShards C.longlong, parityShards C.longlong, ecMaxGoroutine C.longlong) CGoHandle {
	return handleFromPtr_Ptr_client_Client(client.NewClient(int(dataShards), int(parityShards), int(ecMaxGoroutine)))

}

// ---- Functions ---

//export client_FlushLog
func client_FlushLog(goRun C.char) {
	if boolPyToGo(goRun) {
		go client.FlushLog()
	} else {
		client.FlushLog()
	}
}

//export client_NewEncoder
func client_NewEncoder(dataShards C.longlong, parityShards C.longlong, ecMaxGoroutine C.longlong) CGoHandle {
	return handleFromPtr_reedsolomon_Encoder(client.NewEncoder(int(dataShards), int(parityShards), int(ecMaxGoroutine)))

}

//export client_CreateLog
func client_CreateLog(opts CGoHandle, goRun C.char) {
	if boolPyToGo(goRun) {
		go client.CreateLog(deptrFromHandle_Map_string_interface_(opts))
	} else {
		client.CreateLog(deptrFromHandle_Map_string_interface_(opts))
	}
}
